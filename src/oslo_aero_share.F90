module oslo_aero_share

  !---------------------------------------------------------------------------------
  ! Module to set up register aerosols indexes, number of gas and particle
  ! species and their scavenging rates. Tables for humidity growth
  !---------------------------------------------------------------------------------

  use shr_kind_mod,   only: r8 => shr_kind_r8
  use ppgrid,         only: pcols, pver
  use constituents,   only: pcnst, cnst_name, cnst_get_ind
  use mo_tracname,    only: solsym
  use cam_abortutils, only: endrun
  use physics_buffer, only: physics_buffer_desc, pbuf_get_field
  use physconst,      only: pi
  !
  implicit none
  public          ! Make default type private to the module

  !---------------------------
  ! Public interfaces
  !---------------------------

  public :: aero_register           ! register consituents
  public :: is_process_mode         ! Check is an aerosol specie is a process mode
  public :: isAerosol               ! Check is specie is aerosol (i.e. gases get .FALSE. here)
  public :: getTracerIndex
  public :: getNumberOfTracersInMode
  public :: getNumberOfBackgroundTracersInMode
  public :: getCloudTracerIndex
  public :: getCloudTracerIndexDirect
  public :: getCloudTracerName
  public :: chemistryIndex
  public :: physicsIndex
  public :: getDryDensity
  public :: isTracerInMode
  public :: fillAerosolTracerList
  public :: getNumberOfAerosolTracers
  public :: fillInverseAerosolTracerList
  public :: qqcw_get_field
  !
  public :: calculateNumberConcentration
  public :: calculateNumberMedianRadius
  public :: calculateEquivalentDensityOfFractalMode
  public :: calculatedNdLogR
  public :: calculateLognormalCDF
  !
  public :: init_interp_constants

  !---------------------------
  ! Public parameters
  !---------------------------

  ! Logic for use with CAM-Nor-physics
  logical :: use_oslo_aero = .true.

  ! Define lognormal size parameters for each size mode (dry, at point of emission/production)
  integer, parameter :: nmodes   = 14
  integer, parameter :: nbmodes  = 10
  integer, parameter :: nbands   = 14 ! number of aerosol spectral bands in SW
  integer, parameter :: nlwbands = 16 ! number of aerosol spectral bands in LW
  integer, parameter :: nbmp1    = 11 ! number of first non-background mode
  integer, parameter :: max_tracers_per_mode = 7

  integer, parameter :: numberOfExternallyMixedModes = 4    !Modes 0;11-14 (13 is not used in lifecycle)
  integer, parameter :: numberOfInternallyMIxedMOdes = 9    !Modes 1-10 (3 is not used in lifecycle)
  integer, parameter :: numberOfProcessModeTracers = 6

  integer,  parameter :: nBinsTab = 44                    ![nbr] number of tabulated bins

  real(r8), parameter :: rTabMin = 1.e-9_r8               ![m] smallest lookup table size
  real(r8), parameter :: rTabMax = 20.e-6_r8              ![m] largest lookup table size
  real(r8), parameter :: rMinAquousChemistry = 0.05e-6_r8 !Smallest particle which can receive aquous chemistry mass
  real(r8), parameter :: sq2pi = 1._r8/sqrt(2.0_r8*pi)
  real(r8), parameter :: smallConcentration = 1.e-100_r8  !duplicate, sync with smallNumber in Const
  real(r8), parameter :: smallNumber = 1.e-100_r8

  integer, parameter :: n_tracers_in_mode(0:nmodes) = (/ 1, 4, 3, 0, 5, 7, 7, 7, 7, 7, 7, 0, 1, 0, 2 /)
  integer, parameter :: n_background_tracers_in_mode(0:nmodes) = (/ 1,2,1,0,2,1,1,1,1,1,1,0,1,0,2 /)

  ! Define aerosol types and their properties..
  integer, parameter :: N_AEROSOL_TYPES      = 5
  integer, parameter :: AEROSOL_TYPE_SULFATE = 1
  integer, parameter :: AEROSOL_TYPE_BC      = 2
  integer, parameter :: AEROSOL_TYPE_OM      = 3
  integer, parameter :: AEROSOL_TYPE_DUST    = 4
  integer, parameter :: AEROSOL_TYPE_SALT    = 5

  ! Define aerosol modes
  integer, parameter :: MODE_IDX_BC_EXT_AC             = 0  !Externally mixed BC accumulation mode
  integer, parameter :: MODE_IDX_SO4SOA_AIT            = 1  !SO4 and SOA in aitken mode, Created from 11 by growth (condensation) of SO4
  integer, parameter :: MODE_IDX_BC_AIT                = 2  !Created from 12 by growth (condensation)  SO4
  integer, parameter :: MODE_IDX_NOT_USED              = 3  !Not used
  integer, parameter :: MODE_IDX_OMBC_INTMIX_COAT_AIT  = 4  !Created from 14 by growth (condensation) of SO4 and from cloud processing/wet-phas
  integer, parameter :: MODE_IDX_SO4_AC                = 5  !Accumulation mode SO4 (mode will have other comps added)
  integer, parameter :: MODE_IDX_DST_A2                = 6  !Accumulation mode dust (mode will have other comps added)
  integer, parameter :: MODE_IDX_DST_A3                = 7  !Coarse mode dust (mode will have other comps added)
  integer, parameter :: MODE_IDX_SS_A1                 = 8  !Fine mode sea-salt (mode will have other comps added)
  integer, parameter :: MODE_IDX_SS_A2                 = 9  !Accumulation mode sea-salt (mode will have other comps added)
  integer, parameter :: MODE_IDX_SS_A3                 = 10 !Coarse mode sea-salt (mode will have other comps added)
  integer, parameter :: MODE_IDX_SO4SOA_NUC            = 11 !SO4 and SOA nucleation mode
  integer, parameter :: MODE_IDX_BC_NUC                = 12 !BC nucleation mode
  integer, parameter :: MODE_IDX_LUMPED_ORGANICS       = 13 !not used in lifecycle, but some extra mass goes here when max. allowed LUT conc. are too small
  integer, parameter :: MODE_IDX_OMBC_INTMIX_AIT       = 14 !mix quickly formed in fire-plumes

  ! Number median radius of background emissions THESE DO NOT ASSUME IMPLICIT GROWTH!!
  real(r8), parameter :: originalNumberMedianRadius(0:nmodes) =        &
       1.e-6_r8* (/ 0.0626_r8,                                         & !0
                    0.0118_r8, 0.024_r8, 0.04_r8,  0.04_r8, 0.075_r8,  & !1-5
                    0.22_r8,   0.63_r8,   0.0475_r8, 0.30_r8, 0.75_r8, & !6-10    ! SS: Salter et al. (2015)
                    0.0118_r8, 0.024_r8, 0.04_r8,  0.04_r8    /)         !11-14

  ! sigma of background aerosols
  real(r8), parameter :: originalSigma(0:nmodes) =  &
       (/1.6_r8,                                    & !0
         1.8_r8, 1.8_r8, 1.8_r8, 1.8_r8, 1.59_r8,   & !1-5
         1.59_r8, 2.0_r8, 2.1_r8, 1.72_r8, 1.60_r8, & !6-10   ! SS: Salter et al. (2015)
         1.8_r8, 1.8_r8, 1.8_r8, 1.8_r8  /)           !11-14

  !Radius used for the modes in the lifeCycle MAY ASSUME SOME GROWTH ALREADY HAPPENED
  real(r8), parameter :: lifeCycleNumberMedianRadius(0:nmodes) = &
       1.e-6_r8*(/ 0.0626_r8, 0.025_r8, 0.025_r8 , 0.04_r8,   0.06_r8,   0.075_r8, &
                   0.22_r8,   0.63_r8,  0.0475_r8, 0.30_r8,   0.75_r8,  &    ! Salter et al. (2015)
                   0.0118_r8, 0.024_r8, 0.04_r8  , 0.04_r8    /)

  !Sigma based on original lifecycle code (taken from "sigmak" used previously in lifecycle code)
  real(r8), parameter :: lifeCycleSigma(0:nmodes) =  &
       (/1.6_r8, 1.8_r8, 1.8_r8, 1.8_r8, 1.8_r8, &   !0-4
         1.59_r8, 1.59_r8, 2.0_r8,               &   !5,6,7 (SO4+dust)
         2.1_r8, 1.72_r8, 1.6_r8,                &   !8-10  (SS)     ! Salter et al. (2015)
         1.8_r8, 1.8_r8, 1.8_r8, 1.8_r8/)            !11-14

  !Below cloud scavenging coefficients for modes which have an actual size
  real(r8), parameter :: belowCloudScavengingCoefficient(0:nmodes) =     &
       (/ 0.01_r8  ,  0.02_r8 , 0.02_r8  ,  0.0_r8 ,   0.02_r8,   0.01_r8, & !(0-5)
          0.02_r8  ,  0.2_r8  , 0.02_r8  ,  0.02_r8,   0.5_r8,             & !6-10 (DUST+SS)
          0.04_r8  ,  0.08_r8 , 0.0_r8   ,  0.02_r8    /)                    ! SO4_n, bc_n, N/A og bc/oc

  ! Treatment of process-modes!
  ! The tracers indices can not be set here since they are not known on compile time
  ! tracerInProcessMode = (/l_so4_a1, l_so4_a2, l_so4_ac, l_om_ac, l_bc_ac, l_soa_a1 /)

  !The process modes need an "efficient size" (Why does A1 have a different size than the others??)
  real(r8), parameter :: processModeNumberMedianRadius(numberOfProcessModeTracers) = &
       (/ 0.04e-6_r8, 0.1e-6_r8, 0.1e-6_r8, 0.1e-6_r8, 0.1e-6_r8, 0.04e-6_r8 /)

  !The process modes need an "efficient sigma"
  real(r8), parameter :: processModeSigma(numberOfProcessModeTracers) = &
       (/ 1.8_r8, 1.59_r8, 1.59_r8, 1.59_r8, 1.59_r8, 1.8_r8  /)

  real(r8), parameter :: belowCloudScavengingCoefficientProcessModes(numberOfProcessModeTracers) = &
       (/0.02_r8, 0.01_r8, 0.02_r8, 0.02_r8, 0.02_r8, 0.02_r8 /)

  real(r8), parameter :: aThird = 1.0_r8/3.0_r8

  real(r8), parameter :: e=2.718281828_r8
  real(r8), parameter :: eps=1.0e-30_r8

  !---------------------------
  ! Public constants
  !---------------------------

  real(r8) :: nk(0:nmodes,nbinsTab)     !dN/dlogr for modes
  real(r8) :: normnk(0:nmodes,nbinsTab) !dN for modes (sums to one over size range)
  real(r8) :: rBinEdge(nBinsTab+1)
  real(r8) :: rBinMidpoint(nBinsTab)
  real(r8) :: volumeToNumber(0:nmodes)  !m3 ==> #
  real(r8) :: numberToSurface(0:nmodes) !# ==> m2

  ! Constants used in interpolation
  ! Internal mixtures of process-tagged mass
  ! cate : total added mass (Âµg/m3 per particle per cm3) from condensation
  !        and wet phase chemistry/cloud processing, for kcomp = 1-2.
  !        cate should be scaled up/down whenever the modal parameters (modal
  !        radius and width) are increased/decreased a lot.
  ! cat  : total added mass (Âµg/m3 per particle per cm-3) from coagulation, condensation
  !        and wet phase chemistry/cloud processing, for kcomp = 5-10.
  !        cat should be scaled up/down whenever the modal parameters (modal
  !        radius and width) are increased/decreased a lot.
  ! fac  : mass fraction of cat or cate from coagulating carbonaceous aerosols (BC+OM).
  !        The remaining mass cate*(1-fac) or cat*(1-fac) is SO4.
  ! fbc  : mass fraction of BC from coagulating carbonaceous aerosols, BC/(BC+OM).
  ! faq  : mass fraction of sulfate which is produced in wet-phase, SO4aq/SO4.
  !        The remaining SO4 mass, SO4*(1-faq), is from condensation.

  real(r8) :: rh(10)
  real(r8) :: fombg(6), fbcbg(6), fac(6), fbc(6), faq(6)
  real(r8) :: cate(4,16)
  real(r8) :: cat(5:10,6)

  ! relative humidity (RH, as integer for output variable names) for use in AeroCom code
  integer  :: RF(6)

  ! AeroCom specific RH input variables for use in opticsAtConstRh.F90
  integer  :: irhrf1(6)
  real(r8) :: xrhrf(6)

  integer :: tracerInProcessMode(numberOfProcessModeTracers)
  integer :: processModeMap(pcnst)

  ! NUMBERS BELOW ARE ESSENTIAL TO CALCULATE HYGROSCOPICITY AND THEREFORE INDIRECT EFFECT!
  ! These numbers define the "hygroscopicity parameter" Numbers are selected so that they give reasonable hygroscipity
  ! note that changing numbers individually changes the hygroscopicity!
  ! Hygroscopicity is defined in Abdul-Razzak and S. Ghan: (B in their eqn 4)
  ! A parameterization of aerosol activation 2. Multiple aerosol types, JGR, vol 105, noD5, pp 6837
  ! http://onlinelibrary.wiley.com/doi/10.1029/1999JD901161/abstract
  !
  ! Further note that changing any of these numbers without changing aerotab will lead to
  ! inconsistencies in the simulation since Aerotab tabulates hygroscopical growth!
  !
  ! Main reference for numbers chosen: Ghan et al MIRAGE paper (JRG, vol 106, D6, pp 5295), 2001 References:
  ! SULFATE : Using same numbers as MIRAGE paper (ammonium sulfate)
  ! BC      : Does not really matter as long as soluble mass fraction is small
  !           However, numbers below reproduces values from MIRAGE paper
  !           New mass density (October 2016) is based on Bond and Bergstrom (2007): Light Absorption
  !           by Carbonaceous Particles: An Investigative Review, Aerosol Science and Technology, 40:27¡¹67.
  ! OM      : Soluble mass fraction tuned to give B of MIRAGE Paper
  ! DUST    : The numbers give B of ~ 0.07 (high end of Kohler, Kreidenweis et al, GRL, vol 36, 2009.
  !                                  (10% as soluble mass fraction seems reasonable)
  !                                  (see also Osada et al, Atmospheric Research, vol 124, 2013, pp 101
  ! SEA SALT: Soluble mass fraction tuned to give consistent values for (r/r0) at 99% when using the parametrization in
  !           Koepke, Hess, Schult and Shettle: Max-Plack-Institut fur Meteorolgie, report No. 243 "GLOBAL AEROSOL DATA SET"
  !           These values give "B" of 1.20 instead of 1.16 in MIRAGE paper.

  character(len=8) :: aerosol_type_name(N_AEROSOL_TYPES) = &
       (/"SULFATE ", "BC      ","OM      ", "DUST    ", "SALT    " /)
  real(r8) :: aerosol_type_density(N_AEROSOL_TYPES) =               &
       (/1769.0_r8, 1800.0_r8,  1500.0_r8, 2600.0_r8,  2200.0_r8 /)   !kg/m3
  real(r8) :: aerosol_type_molecular_weight(N_AEROSOL_TYPES) =      &
       (/132.0_r8,  12.0_r8,    168.2_r8,  135.0_r8,   58.44_r8  /)   !kg/kmol
  real(r8) :: aerosol_type_osmotic_coefficient(N_AEROSOL_TYPES) =   &
       (/0.7_r8,    1.111_r8,     1.0_r8,    1.0_r8,     1.0_r8    /) ![-]
  real(r8) :: aerosol_type_soluble_mass_fraction(N_AEROSOL_TYPES) = &
       (/1.0_r8,    1.67e-7_r8, 0.8725_r8, 0.1_r8,     0.885_r8  /)   ![-]
  real(r8) :: aerosol_type_number_of_ions(N_AEROSOL_TYPES) =        &
       (/3.0_r8,    1.0_r8,     1.0_r8,    2.0_r8,     2.0_r8    /)   ![-]

  real(r8) :: rhopart(pcnst)
  real(r8) :: sgpart(pcnst)
  real(r8) :: osmoticCoefficient(pcnst)
  real(r8) :: numberOfIons(pcnst)
  real(r8) :: solubleMassFraction(pcnst)
  integer  :: aerosolType(pcnst)
  real(r8) :: numberFractionAvailableAqChem(nbmodes)
  real(r8) :: invrhopart(pcnst)

  !These tables describe how the tracers behave chemically
  integer, dimension(numberOfExternallyMixedModes) :: externallyMixedMode = &
       (/MODE_IDX_BC_EXT_AC,  &
       MODE_IDX_SO4SOA_NUC, &
       MODE_IDX_BC_NUC,     &
       MODE_IDX_OMBC_INTMIX_AIT /)

  integer, dimension(numberOfInternallyMixedMOdes) :: internallyMixedMode = &
       (/MODE_IDX_SO4SOA_AIT,           &
       MODE_IDX_BC_AIT,               &
       MODE_IDX_OMBC_INTMIX_COAT_AIT, &
       MODE_IDX_SO4_AC,               &
       MODE_IDX_DST_A2,               &
       MODE_IDX_DST_A3,               &
       MODE_IDX_SS_A1,                &
       MODE_IDX_SS_A2,                &
       MODE_IDX_SS_A3 /)

  ! species indices for individual camuio species
  integer :: l_so4_na, l_so4_a1, l_so4_a2, l_so4_ac
  integer :: l_bc_n, l_bc_ax, l_bc_ni, l_bc_a, l_bc_ai,l_bc_ac
  integer :: l_om_ni, l_om_ai, l_om_ac
  integer :: l_so4_pr
  integer :: l_dst_a2, l_dst_a3
  integer :: l_ss_a1, l_ss_a2, l_ss_a3, l_h2so4
  integer :: l_soa_na, l_soa_a1, l_soa_lv, l_soa_sv

  integer :: n_aerosol_tracers !number of aerosol tracers
  integer :: imozart

  ! Number of transported tracers in each mode
  integer  :: tracer_in_mode(0:nmodes, max_tracers_per_mode)

  ! Growth of aerosols, duplicated in oslo_aero_sw_tables
  real(r8) :: rdivr0(10,pcnst)

  real(r8) :: rhtab(10) = (/ 0.0_r8, 0.37_r8, 0.47_r8, 0.65_r8, 0.75_r8, 0.80_r8, 0.85_r8, 0.90_r8, 0.95_r8, 0.98_r8/)

  integer  :: cloudTracerIndex(pcnst)
  character(len=20) :: cloudTracerName(pcnst)

  integer, private :: qqcw(pcnst)=-1 ! Remaps modal_aero indices into pbuf

!===============================================================================
contains
!===============================================================================

  function is_process_mode(l_index_in, isChemistry) result(answer)

    !-----------------------------------------------------------------------
    ! For a tracer in an aerosol mode, check if this isactually a real
    ! tracer or a process mode
    !-----------------------------------------------------------------------

    integer, intent(in)  :: l_index_in
    logical, intent(in)  :: isChemistry  !true if called from chemistry

    integer :: l_index_phys
    logical :: answer

    l_index_phys = l_index_in
    if (isChemistry) then
       l_index_phys = l_index_phys + iMozart - 1
    endif

    ! return true if tracer is a "process mode"
    answer = .false.
    if(l_index_phys .eq. l_so4_a1 .or. &
         l_index_phys .eq. l_so4_a2 .or. &
         l_index_phys .eq. l_so4_ac .or. &
         l_index_phys .eq. l_bc_ac  .or. &
         l_index_phys .eq. l_om_ac  .or. &
         l_index_phys .eq. l_soa_a1 ) then
       answer = .true.
    endif
  end function is_process_mode

  !===============================================================================

  subroutine aero_register

    !-----------------------------------------------------------------------
    ! Register aerosol modes and indices, should be changed to read in values
    ! instead of hard-coding it.
    !-----------------------------------------------------------------------

    use mpishorthand
    use physics_buffer,  only: pbuf_add_field, dtype_r8
    use ppgrid,          only: pcols, pver, pverp

    integer :: idx_dum, l,m,mm
    logical :: isAlreadyCounted(pcnst)

    ! register the species

    call cnst_get_ind('SO4_NA' ,l_so4_na, abort=.true.) !Aitken mode sulfate (growth from so4_n)
    call cnst_get_ind('SO4_A1' ,l_so4_a1, abort=.true.) !sulfate condensate (gas phase production)
    call cnst_get_ind('SO4_A2' ,l_so4_a2, abort=.true.) !sulfate produced in aq. chemistry
    call cnst_get_ind('SO4_AC' ,l_so4_ac, abort=.true.) !sulfate from coagulation processes
    call cnst_get_ind('SO4_PR' ,l_so4_pr, abort=.true.) !sulfate emitted as primary

    call cnst_get_ind('BC_N'   ,l_bc_n,   abort=.true.) !emissions (mainly industry) lost through coagulation
    call cnst_get_ind('BC_AX'  ,l_bc_ax,  abort=.true.) !externally mixed (fluffy and impossible to activate)
    call cnst_get_ind('BC_NI'  ,l_bc_ni,  abort=.true.) !mixed with oc (mainly biomass), externally mixed otherwise (before condensation etc)
    call cnst_get_ind('BC_A'   ,l_bc_a,   abort=.true.) !formed when bc_n grows by condensation
    call cnst_get_ind('BC_AI'  ,l_bc_ai,  abort=.true.) !formed when bc_ni grows by condensation
    call cnst_get_ind('BC_AC'  ,l_bc_ac,  abort=.true.) !bc from coagulation processes

    call cnst_get_ind('OM_NI'  ,l_om_ni,  abort=.true.) !om (mainly from biomass), emitted
    call cnst_get_ind('OM_AI'  ,l_om_ai,  abort=.true.) !om formed when condensation growth of om_ni
    call cnst_get_ind('OM_AC'  ,l_om_ac,  abort=.true.) !om from coagulation processes

    call cnst_get_ind('DST_A2' ,l_dst_a2, abort=.true.) !Dust accumulation mode
    call cnst_get_ind('DST_A3' ,l_dst_a3, abort=.true.) !Dust coarse mode

    call cnst_get_ind('SS_A1'  ,l_ss_a1,  abort=.true.) !Sea salt fine mode
    call cnst_get_ind('SS_A2'  ,l_ss_a2,  abort=.true.) !Sea salt accumulation mode
    call cnst_get_ind('SS_A3'  ,l_ss_a3,  abort=.true.) !Sea salt coarse mode

    ! register SOA species
    call cnst_get_ind('SOA_NA' ,l_soa_na, abort=.true.) !Aitken mode SOA with SO4 and SOA condensate
    call cnst_get_ind('SOA_A1' ,l_soa_a1, abort=.true.) !SOA condensate
    call cnst_get_ind('SOA_LV' ,l_soa_lv, abort=.true.) !Gas phase low volatile SOA
    call cnst_get_ind('SOA_SV' ,l_soa_sv, abort=.true.) !Gas phase semi volatile SOA

    ! gas phase h2so4
    call cnst_get_ind('H2SO4'  ,l_h2so4, abort=.true.)

    ! Register the tracers in modes
    call registerTracersInMode()

    ! Set the aerosol types
    aerosolType(:)        = -99
    aerosolType(l_so4_na) = AEROSOL_TYPE_SULFATE
    aerosolType(l_so4_a1) = AEROSOL_TYPE_SULFATE
    aerosolType(l_so4_a2) = AEROSOL_TYPE_SULFATE
    aerosolType(l_so4_ac) = AEROSOL_TYPE_SULFATE
    aerosolType(l_so4_pr) = AEROSOL_TYPE_SULFATE
    aerosolType(l_bc_n)   = AEROSOL_TYPE_BC
    aerosolType(l_bc_ax)  = AEROSOL_TYPE_BC
    aerosolType(l_bc_ni)  = AEROSOL_TYPE_BC
    aerosolType(l_bc_a)   = AEROSOL_TYPE_BC
    aerosolType(l_bc_ai)  = AEROSOL_TYPE_BC
    aerosolType(l_bc_ac)  = AEROSOL_TYPE_BC
    aerosolType(l_om_ni)  = AEROSOL_TYPE_OM
    aerosolType(l_om_ai)  = AEROSOL_TYPE_OM
    aerosolType(l_om_ac)  = AEROSOL_TYPE_OM
    aerosolType(l_dst_a2) = AEROSOL_TYPE_DUST
    aerosolType(l_dst_a3) = AEROSOL_TYPE_DUST
    aerosolType(l_ss_a1)  = AEROSOL_TYPE_SALT
    aerosolType(l_ss_a2)  = AEROSOL_TYPE_SALT
    aerosolType(l_ss_a3)  = AEROSOL_TYPE_SALT
    aerosolType(l_soa_na) = AEROSOL_TYPE_OM
    aerosolType(l_soa_a1) = AEROSOL_TYPE_OM

    rhopart(:)= 1000.0_r8

    ! assign values based on aerosol type
    do m=0,nmodes
       do l=1,n_tracers_in_mode(m)
          mm= getTracerIndex(m,l,.false.)
          osmoticCoefficient(mm)  = aerosol_type_osmotic_coefficient(aerosolType(mm))
          rhopart(mm)             = aerosol_type_density(aerosolType(mm))
          solubleMassFraction(mm) = aerosol_type_soluble_mass_fraction(aerosolType(mm))
          numberOfIons(mm)        = aerosol_type_number_of_ions(aerosolType(mm))
       end do
    end do

    !SPECIAL CASES OF AEROSOL PROPERTIES:
    !Density of bc_ax is rewritten later (calculated from fractal dimension)
    !so4_a2 is different since it is ammonium sulfate and not sulf. acid.
    rhopart(l_so4_a2) = 1769.0_r8

    !These are not really particles, but set densities for the condenseable vapours
    !used by condtend
    rhopart(l_h2so4)= 1841.0_r8
    rhopart(l_soa_lv) = aerosol_type_density(AEROSOL_TYPE_OM)
    rhopart(l_soa_sv) = aerosol_type_density(AEROSOL_TYPE_OM)

    ! Inverse calculated to avoid unneeded divisions in loop
    invrhopart(:)=1._r8/rhopart(:)

    !Set process mode sizes
    tracerInProcessMode = (/l_so4_a1, l_so4_a2, l_so4_ac, l_om_ac, l_bc_ac, l_soa_a1 /)
    processModeMap(:)=-99 !Force error if using unset values
    do l =1,pcnst
       do m=1,numberOfProcessModeTracers
          if(tracerInProcessMode(m) .eq. l)then
             processModeMap(l)=m
          end if
       end do
    end do

    ! Find out first mozart tracers (fxm: short lived species might mess up this!)
    call cnst_get_ind(trim(solsym(1)), imozart, abort=.true.)

    !Add the cloud-tracers
    isAlreadyCounted(:) = .false.
    cloudTracerIndex(:) = -1
    do m=1,nmodes
       do l=1,n_tracers_in_mode(m)
          mm= getTracerIndex(m,l,.false.)
          if(.not. isAlreadyCounted(mm))then
             cloudTracerName(mm) = trim(cnst_name(mm))//"_OCW"
             call pbuf_add_field(trim(cloudTracerName(mm)), 'global', dtype_r8, (/pcols,pver/), idx_dum)
             ! Set the module variable qqcw(mm) to be set to idx_dum
             call qqcw_set_ptr(mm,idx_dum)
             cloudTracerIndex(mm) = idx_dum
             isAlreadyCounted(mm) = .true.
          endif
       end do
    end do

    !Find out how many aerosol-tracers we carry
    isAlreadyCounted(:) = .false.
    n_aerosol_tracers = 0
    do m=1,nmodes
       do l=1,n_tracers_in_mode(m)
          mm=getTracerIndex(m,l,.false.)
          if(.not. isAlreadyCounted(mm))then
             n_aerosol_tracers = n_aerosol_tracers + 1
             isAlreadyCounted(mm)=.true.
          endif
       end do
    end do

    !Tabulated rh-growth for all species
    call inittabrh

  end subroutine aero_register

  !=============================================================================
  function getNumberOfAerosolTracers()RESULT(numberOfTracers)
    integer :: numberOfTracers
    numberOfTracers = n_aerosol_tracers
  end function getNumberOfAerosolTracers

  !=============================================================================
  function chemistryIndex(phys_index) RESULT (chemistryIndexOut)
    integer, intent(in) :: phys_index
    integer             :: chemistryIndexOut
    chemistryIndexOut = phys_index - imozart + 1
  end function chemistryIndex

  !=============================================================================
  function physicsIndex(chem_index) RESULT(physIndexOut)
    integer, intent(in) :: chem_index
    integer             :: physIndexOut
    physIndexOut = chem_index + imozart - 1
  end function physicsIndex

  !=============================================================================
  function isAerosol(phys_index) RESULT(answer)
    integer, intent(in) :: phys_index
    logical answer
    answer=.FALSE.
    if(aerosolType(phys_index) .gt. 0)then
       answer = .TRUE.
    endif
  end function isAerosol

  !=============================================================================
  function getNumberOfTracersInMode(modeIndex) RESULT(numberOfSpecies)
    integer, intent(in)        :: modeIndex
    integer numberOfSpecies
    numberOfSpecies = n_tracers_in_mode(modeIndex)
  end function getNumberOfTracersInMode

  !=============================================================================
  function getNumberOfBackgroundTracersInMode(modeIndex) RESULT (numberOfBackgroundSpecies)
    integer, intent(in)       :: modeIndex
    integer numberOfBackgroundSpecies
    numberOfBackgroundSpecies = n_background_tracers_in_mode(modeIndex)
  end function getNumberOfBackgroundTracersInMode

  !=============================================================================
  function getTracerIndex(modeIndex, componentIndex, isChemistry) RESULT(tracerIndex)
    !purpose: Ask for an index in mode
    !The index is the index in the q-array
    !Some tracers may exist in several modes (is that a problem??)
    integer, intent(in) :: modeIndex
    integer, intent(in) :: componentIndex
    logical, intent(in) :: isChemistry
    integer tracerIndex
    if(isChemistry)then
       !This is tracer index in physics array
       tracerIndex = tracer_in_mode(modeIndex,componentIndex)-imozart+1
    else
       tracerIndex = tracer_in_mode(modeIndex,componentIndex)
    endif
  end function getTracerIndex

  !===============================================================================
  function getCloudTracerIndex(modeIndex, componentIndex) RESULT(cloud_tracer_index)

    ! Obtain an index in the physics-buffer for a component in the lifecycle scheme

    integer, intent(in)   :: modeIndex
    integer, intent(in)   :: componentIndex

    integer :: tracerIndex
    integer :: cloud_tracer_index

    if(componentIndex == 0)then
       !Special key for number concentration of a mode
       call endrun("error no such species")
    else if (componentIndex > 0)then
       !Lifecycle specie in a mode
       tracerIndex = getTracerIndex(modeIndex,componentIndex,.false.)
       cloud_tracer_index = cloudTracerIndex(tracerIndex)       !ak: Index in phys-buffer
    else
       call endrun("negative componentindex in getCloudTracerIndex")
    endif
  end function getCloudTracerIndex

  !===============================================================================
  function getCloudTracerIndexDirect(tracerIndex) RESULT(cloudTracerIndexOut)
    !returns index in pbuf for the corresponding cloud tracer with physics index "tracerIndex"
    !returns "-1" if the tracer does not have any corresponding cloud tracer
    integer, intent(in) :: tracerIndex
    integer             :: cloudTracerIndexOut
    cloudTracerIndexOut = cloudTracerIndex(tracerIndex)
  end function getCloudTracerIndexDirect

  !===============================================================================
  function getDryDensity(m,l) RESULT(density)
    integer, intent(in) :: m !mode index
    integer, intent(in) :: l !tracer index
    real(r8) :: density
    density =  rhopart(tracer_in_mode(m,l))
  end function getDryDensity

  !===============================================================================
  function getCloudTracerName(tracerIndex) RESULT(cloudTracerNameOut)
    integer, intent(in) :: tracerIndex
    character(len=20)   :: cloudTracerNameOut
    cloudTracerNameOut = trim(cloudTracerName(tracerIndex))
  end function getCloudTracerName

  !===============================================================================
  subroutine fillAerosolTracerList(aerosolTracerList)
    integer, dimension (:), intent(out) :: aerosolTracerList
    logical, dimension(pcnst)          :: alreadyFound
    integer :: m,l,mm,nTracer
    alreadyFound(:) = .FALSE.
    nTracer = 0
    do m=1,nmodes
       do l=1,n_tracers_in_mode(m)
          mm=getTracerIndex(m,l,.FALSE.)
          if(.NOT.alreadyFound(mm))then
             nTracer = nTracer + 1
             alreadyFound(mm) = .TRUE.
             aerosolTracerList(nTracer) = mm
          end if
       end do
    end do
  end subroutine fillAerosolTracerList

  !===============================================================================
  subroutine fillInverseAerosolTracerList(aerosolTracerList, inverseAerosolTracerList, n_aerosol_tracers)
    integer, dimension(:), intent(in)  :: aerosolTracerList
    integer, intent(in)                :: n_aerosol_tracers
    integer, dimension(pcnst), intent(out) :: inverseAerosolTracerList
    integer                                :: i

    inverseAerosolTracerList(:) = -99
    do i=1,n_aerosol_tracers
       inverseAerosolTracerList(aerosolTracerList(i)) = i
    end do
  end subroutine fillInverseAerosolTracerList

  !===============================================================================
  subroutine registerTracersInMode()
    !Register tracer index in modes
    tracer_in_mode(:,:) = -1 !undefined

    !externally mixed bc
    tracer_in_mode(MODE_IDX_BC_EXT_AC, 1:n_tracers_in_mode(MODE_IDX_BC_EXT_AC)) = (/l_bc_ax/)

    !sulphate + soa, sulfate condensate.
    tracer_in_mode(MODE_IDX_SO4SOA_AIT, 1:n_tracers_in_mode(MODE_IDX_SO4SOA_AIT) ) = &
         (/l_so4_na, l_soa_na, l_so4_a1, l_soa_a1/)

    !bc + sulfate condensate
    tracer_in_mode(MODE_IDX_BC_AIT,1:n_tracers_in_mode(MODE_IDX_BC_AIT))  = &
         (/l_bc_a, l_so4_a1, l_soa_a1/)

    !index not used
    !tracer_in_mode(MODE_IDX_NOT_USED, 1:n_tracers_in_mode(MODE_IDX_NOT_USED)) = (/-1/)

    !om / bc internally mixed with sulfate condensate and aquous phase sulfate
    tracer_in_mode(MODE_IDX_OMBC_INTMIX_COAT_AIT, 1:n_tracers_in_mode(MODE_IDX_OMBC_INTMIX_COAT_AIT))= &
         (/l_bc_ai, l_om_ai, l_so4_a1, l_so4_a2, l_soa_a1 /)

    !accumulation mode sulfate with coagulate, condensate and aquous phase sulfate
    tracer_in_mode(MODE_IDX_SO4_AC, 1:n_tracers_in_mode(MODE_IDX_SO4_AC)) = &
         (/l_so4_pr, l_bc_ac, l_om_ac, l_so4_a1, l_so4_ac, l_so4_a2, l_soa_a1  /)

    !ac-mode dust with sulfate coagulate, condensate sulfate and wet-phase sulfate
    tracer_in_mode(MODE_IDX_DST_A2, 1:n_tracers_in_mode(MODE_IDX_DST_A2)) = &
         (/l_dst_a2, l_bc_ac, l_om_ac, l_so4_a1, l_so4_ac, l_so4_a2, l_soa_a1 /)

    !coarse mode dust  with sulfate coagulate, condensate sulfate and wet-phase sulfate
    tracer_in_mode(MODE_IDX_DST_A3, 1:n_tracers_in_mode(MODE_IDX_DST_A3)) = &
         (/l_dst_a3, l_bc_ac, l_om_ac, l_so4_a1, l_so4_ac, l_so4_a2, l_soa_a1 /)

    !at-mode ss with sulfate coagulate, condensate sulfate and wet-phase sulfate
    tracer_in_mode(MODE_IDX_SS_A1, 1:n_tracers_in_mode(MODE_IDX_SS_A1))   = &
         (/l_ss_a1, l_bc_ac, l_om_ac, l_so4_a1, l_so4_ac, l_so4_a2, l_soa_a1 /)

    !ac mode ss with sulfate coagulate, condensate sulfate and wet-phase sulfate
    tracer_in_mode(MODE_IDX_SS_A2, 1:n_tracers_in_mode(MODE_IDX_SS_A2))   = &
         (/l_ss_a2, l_bc_ac, l_om_ac, l_so4_a1, l_so4_ac, l_so4_a2, l_soa_a1 /)

    !coarse mode ss sulfate coagulate, condensate sulfate and wet-phase sulfate
    tracer_in_mode(MODE_IDX_SS_A3, 1:n_tracers_in_mode(MODE_IDX_SS_A3))   = &
         (/l_ss_a3, l_bc_ac, l_om_ac, l_so4_a1, l_so4_ac, l_so4_a2, l_soa_a1 /)

    !sulfate + soa nucleation mode (mode no longer used)
    !tracer_in_mode(MODE_IDX_SO4SOA_NUC, 1:n_tracers_in_mode(MODE_IDX_SO4SOA_NUC)) = (/ -1 /)

    !bc in nucleation mode
    tracer_in_mode(MODE_IDX_BC_NUC, 1:n_tracers_in_mode(MODE_IDX_BC_NUC)) = (/l_bc_n/)

    !lumped organics
    !tracer_in_mode(MODE_IDX_LUMPED_ORGANICS, 1:n_tracers_in_mode(MODE_IDX_LUMPED_ORGANICS)) = (/-1/)

    !intermal mixture bc/oc coated
    tracer_in_mode(MODE_IDX_OMBC_INTMIX_AIT, 1:n_tracers_in_mode(MODE_IDX_OMBC_INTMIX_AIT)) = (/l_bc_ni, l_om_ni/)
  end subroutine registerTracersInMode

  !===============================================================================
  function isTracerInMode(modeIndex, constituentIndex)RESULT(answer)
    integer, intent(in) :: modeIndex
    integer, intent(in) :: constituentIndex

    integer             :: i
    logical             :: answer

    answer = .FALSE.
    do i=1,n_tracers_in_mode(modeIndex)
       if(tracer_in_mode(modeIndex,i) == constituentIndex)then
          answer = .TRUE.
          exit
       endif
    enddo
  end function isTracerInMode

  !===============================================================================
  subroutine inittabrh()

    ! Tables for hygroscopic growth

    integer :: i
    real(r8) :: rr0ss(10),rr0so4(10),rr0bcoc(10)

    data rr0ss / 1.00_r8, 1.00_r8, 1.02_r8, 1.57_r8, 1.88_r8, 1.97_r8, 2.12_r8, 2.35_r8, 2.88_r8, 3.62_r8 /
    data rr0so4 / 1.00_r8, 1.34_r8, 1.39_r8, 1.52_r8, 1.62_r8, 1.69_r8, 1.78_r8, 1.92_r8, 2.22_r8, 2.79_r8 /
    data rr0bcoc / 1.00_r8, 1.02_r8, 1.03_r8, 1.12_r8, 1.17_r8, 1.20_r8, 1.25_r8, 1.31_r8, 1.46_r8, 1.71_r8 /

    rdivr0(:,:)=1._r8

    do i=1,10
       rdivr0(i,l_so4_na)=rr0so4(i)
       rdivr0(i,l_so4_a1)=rr0so4(i)
       rdivr0(i,l_so4_a2)=rr0so4(i)
       rdivr0(i,l_so4_ac)=rr0so4(i)
       rdivr0(i,l_so4_pr)=rr0so4(i)

       rdivr0(i,l_bc_a)=rr0bcoc(i)

       rdivr0(i,l_bc_ni)=rr0bcoc(i)
       rdivr0(i,l_bc_ai)=rr0bcoc(i)
       rdivr0(i,l_bc_ac)=rr0bcoc(i)

       rdivr0(i,l_om_ni)=rr0bcoc(i)
       rdivr0(i,l_om_ai)=rr0bcoc(i)
       rdivr0(i,l_om_ac)=rr0bcoc(i)

       rdivr0(i,l_ss_a1)=rr0ss(i)
       rdivr0(i,l_ss_a2)=rr0ss(i)
       rdivr0(i,l_ss_a3)=rr0ss(i)

       rdivr0(i,l_soa_na)=rr0bcoc(i)
    end do
  end subroutine inittabrh

  !===============================================================================
  subroutine qqcw_set_ptr(index, iptr)
    integer, intent(in) :: index, iptr
    if(index>0 .and. index <= pcnst ) then
       qqcw(index)=iptr
    else
       call endrun('qqcw_set_ptr: attempting to set qqcw pointer already defined')
    end if
  end subroutine qqcw_set_ptr

  !===============================================================================
  function qqcw_get_field(pbuf, index)

    type(physics_buffer_desc), pointer :: pbuf(:)
    integer, intent(in) :: index

    real(r8), pointer :: qqcw_get_field(:,:)

    nullify(qqcw_get_field)
    if (index>0 .and. index <= pcnst) then
       if (qqcw(index)>0) then
          call pbuf_get_field(pbuf, qqcw(index), qqcw_get_field)
       endif
    end if
  end function qqcw_get_field

  !===============================================================================
  subroutine calculateNumberConcentration(ncol, q, rho_air, numberConcentration)

    ! arguments
    integer  , intent(in)  :: ncol                                     !number of columns used
    real(r8) , intent(in)  :: q(pcols,pver,pcnst)                      ![kg/kg] mass mixing ratios
    real(r8) , intent(in)  :: rho_air(pcols,pver)                      ![kg/m3] air density
    real(r8) , intent(out) :: numberConcentration(pcols,pver,0:nmodes) ![#/m3] number concentration

    ! local variables
    integer :: m, l, mm, k

    numberConcentration(:,:,:) = 0.0_r8
    do m = 0, nmodes
       do l=1,getNumberOfBackgroundTracersInMode(m)
          mm = getTracerIndex(m,l,.false.)
          do k=1,pver
             numberConcentration(:ncol,k,m) = numberConcentration(:ncol,k,m) &
                  + ( q(:ncol,k,mm) / getDryDensity(m,l))  !Volume of this tracer
          end do
       end do
    end do

    ! until now, the variable "numberConcentration" actually contained "volume mixing ratio"
    ! the next couple of lines fixes this!
    do m= 0, nmodes
       do k=1,pver
          numberConcentration(:ncol,k,m) = numberConcentration(:ncol,k,m) * rho_air(:ncol,k) * volumeToNumber(m)
       end do
    end do

  end subroutine calculateNumberConcentration

  !===================================================
  subroutine calculateNumberMedianRadius(numberConcentration, volumeConcentration, lnSigma, &
       numberMedianRadius, ncol)

    !Note the "nmodes" here
    real(r8) , intent(in)  :: numberConcentration(pcols,pver,0:nmodes)   ![#/m3] number concentration
    real(r8) , intent(in)  :: volumeConcentration(pcols,pver,nmodes)     ![kg/kg] mass mixing ratios
    real(r8) , intent(in)  :: lnSigma(pcols,pver,nmodes)                 ![kg/m3] air density
    integer  , intent(in)  :: ncol                                       !number of columns used
    real(r8) , intent(out) :: numberMedianRadius(pcols,pver,nmodes)      ![m]

    integer :: n,k

    do n=1,nmodes
       do k=1,pver
          where(volumeConcentration(:ncol,k,n) .gt. 1.e-20_r8)
             numberMedianRadius(:ncol, k, n) = 0.5_r8 &                  !diameter ==> radius
                  * (volumeConcentration(:ncol,k,n)       &              !conversion formula
                  * 6.0_r8/pi/numberConcentration(:ncol,k,n) &
                  *DEXP(-4.5_r8*lnsigma(:ncol,k,n)*lnsigma(:ncol,k,n)))**aThird
          elsewhere
             numberMedianRadius(:ncol,k,n) = originalNumberMedianRadius(n)
          end where
       end do
    end do

  end subroutine calculateNumberMedianRadius

  !===================================================
  function calculateEquivalentDensityOfFractalMode( &
       emissionDensity, emissionRadius, fractalDimension, modeNumberMedianRadius, modeStandardDeviation) &
       result (equivalentDensityOfFractal)

    ! output equivalent density of a fractal mode

    ! arguments
    real(r8), intent(in) :: emissionDensity        ![kg/m3] density at point of emission
    real(r8), intent(in) :: emissionRadius         ![kg/m3] radius at point of emission
    real(r8), intent(in) :: fractalDimension       ![kg/m3] fractal dimension of mode
    real(r8), intent(in) :: modeNumberMedianRadius ![m] number median radius of mode
    real(r8), intent(in) :: modeStandardDeviation  ![m] standard deviation of mode
    real(r8)             :: equivalentDensityOfFractal ! Output

    ! local variables
    real(r8) :: sumVolume
    real(r8) :: sumMass
    real(r8) :: dN, dNdLogR, dLogR
    real(r8) :: densityBin
    integer  :: i

    sumVolume = 0.0_r8
    sumMass   = 0.0_r8
    do i=1, nbinsTab
       dLogR = log(rBinEdge(i+1)/rBinEdge(i))
       dNdLogR = calculatedNdLogR(rBinMidPoint(i), modeNumberMedianRadius, modeStandardDeviation)

       !Equivalent density (decreases with size since larger particles are long "hair like" threads..)
       if (rBinMidPoint(i) < emissionRadius)then
          densityBin = emissionDensity
       else
          densityBin = emissionDensity*(emissionRadius/rBinMidPoint(i))**(3.0 - fractalDimension)
       endif

       !number concentration in this bin
       dN = dNdLogR * dLogR

       !sum up volume and mass (factor of 4*pi/3 omitted since in both numerator and nominator)
       sumVolume = sumVolume + dN * (rBinMidPoint(i)**3)
       sumMass   = sumMass + dN * densityBin * (rBinMidPoint(i)**3)
    end do

    ! Equivalent density is mass by volume
    equivalentDensityOfFractal = sumMass / sumVolume

  end function calculateEquivalentDensityOfFractalMode

  !===================================================
  function calculatedNdLogR(actualRadius, numberMedianRadius, sigma) result (dNdLogR)

    real(r8), intent(in)   :: actualRadius
    real(r8), intent(in)   :: numberMedianRadius
    real(r8), intent(in)   :: sigma

    real(r8) :: logSigma
    real(r8) :: dNdLogR

    logSigma = log(sigma)

    ! This is the formula for the lognormal distribution
    dNdLogR = 1.0_r8/(sqrt(2.0_r8*pi)*log(sigma)) &
         * DEXP(-0.5_r8*(log(actualRadius/numberMedianRadius))**2/(logSigma**2))

  end function calculatedNdLogR

  !===================================================
  function calculateLognormalCDF(actualRadius, numberMedianRadius, sigma) result(CDF)

    !http://en.wikipedia.org/wiki/Log-normal_distribution#Cumulative_distribution_function
    real(r8), intent(in) :: actualRadius
    real(r8), intent(in) :: numberMedianRadius
    real(r8), intent(in) :: sigma
    real(r8)             :: CDF ! output

    real(r8) :: argument

    argument = -1.0_r8*(log(actualRadius/numberMedianRadius) / log(sigma) / sqrt(2.0_r8))
    CDF = 0.5_r8 * erfc(argument)

  end function calculateLognormalCDF

  !===================================================
  subroutine init_interp_constants()

    !---------------------------------------------------------------
    ! set module variables for interpolation of tables
    !---------------------------------------------------------------

    ! Local variables
    integer :: irf, irelh, kcomp, i
    !-----------------------------------------------------------

    ! Defining array bounds for tabulated optical parameters (and r and sigma)
    ! relative humidity (only 0 value used for r and sigma tables):
    rh = (/ 0.0_r8, 0.37_r8, 0.47_r8, 0.65_r8, 0.75_r8, 0.8_r8, 0.85_r8, 0.9_r8, 0.95_r8, 0.995_r8 /)

    ! relative humidity (RH, as integer for output variable names) for use in AeroCom code
    RF = (/0, 40, 55, 65, 75, 85 /)

    ! AeroCom specific RH input variables for use in opticsAtConstRh.F90
    do irf=1,6
       xrhrf(irf)  = real(RF(irf))*0.01_r8
    enddo
    do irelh=1,9
       do irf=1,6
          if(xrhrf(irf)>=rh(irelh).and.xrhrf(irf)<=rh(irelh+1)) then
             irhrf1(irf)=irelh
          endif
       end do
    end do

    ! mass fractions internal mixtures in background (fombg and fbcbg) and mass added to the
    ! background modes (fac, faq, faq)
    fombg = (/ 0.0_r8, 0.2_r8,  0.4_r8, 0.6_r8, 0.8_r8, 1.0_r8  /)
    fac =   (/ 0.0_r8, 0.2_r8,  0.4_r8, 0.6_r8, 0.8_r8, 1.0_r8  /)
    faq =   (/ 0.0_r8, 0.2_r8,  0.4_r8, 0.6_r8, 0.8_r8, 1.0_r8  /)

    ! with more weight on low fractions (thus a logaritmic f axis) for BC,
    ! which is less ambundant than sulfate and OC, and the first value
    ! corresponding to a clean background mode:
    ! and most weight on small concentrations for added mass onto the background:

    fbcbg(1)=1.e-10_r8
    fbc(1)=1.e-10_r8
    do i=2,6
       fbcbg(i)=10**((i-1)/4.0_r8-1.25_r8)
       fbc(i)=fbcbg(i)
    end do

    do kcomp=1,4
       cate(kcomp,1)=1.e-10_r8
       do i=2,16
          if(kcomp.eq.1.or.kcomp.eq.2) then
             cate(kcomp,i)=10.0_r8**((i-1)/3.0_r8-6.222_r8)
          elseif(kcomp.eq.3) then
             cate(kcomp,i)=1.0e-10_r8  ! not used
          else
             cate(kcomp,i)=10.0_r8**((i-1)/3.0_r8-4.301_r8)
          endif
       end do
    end do
    do kcomp=5,10
       cat(kcomp,1) =1.e-10_r8
       do i=2,6
          if(kcomp.eq.5) then
             cat(kcomp,i)=10.0_r8**((i-1)-3.824_r8)
          elseif(kcomp.eq.6) then
             cat(kcomp,i)=10.0_r8**((i-1)-3.523_r8)
          elseif(kcomp.eq.7) then
             cat(kcomp,i)=10.0_r8**((i-1)-3.699_r8)
          elseif(kcomp.eq.8) then
             cat(kcomp,i)=10.0_r8**((i-1)-4.921_r8)
          elseif(kcomp.eq.9) then
             cat(kcomp,i)=10.0_r8**((i-1)-3.301_r8)
          else
             cat(kcomp,i)=10.0_r8**((i-1)-3.699_r8)
          endif
       end do
    end do

  end subroutine init_interp_constants

end module oslo_aero_share
